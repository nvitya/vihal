/*
 * hwrppio.cpp
 *
 *  Created on: Aug 13, 2023
 *      Author: vitya
 */

#include "rp_utils.h"
#include "hwpins.h"
#include "hwrppio_instructions.h"
#include <hwrppio.h>

uint8_t hwpio_reset_done[3];  // will be initialized with zeroes as it goes to the .bss

pio_hw_t * hwpio_init_and_get_regs(uint8_t adevnum)
{
  uint32_t reset_mask;
  pio_hw_t * dregs;

  if (0 == adevnum)
  {
    dregs = pio0_hw;
    reset_mask = RESETS_RESET_PIO0_BITS;
  }
  else if (1 == adevnum)
  {
    dregs = pio1_hw;
    reset_mask = RESETS_RESET_PIO1_BITS;
  }
  else if (2 == adevnum)
  {
    dregs = pio2_hw;
    reset_mask = RESETS_RESET_PIO2_BITS;
  }
  else
  {
    return nullptr;
  }

  if (0 == hwpio_reset_done[adevnum])
  {
    rp_reset_control(reset_mask, true); // issue the reset
    hwpio_reset_done[adevnum] = 1;
  }

  rp_reset_control(reset_mask, false); // remove reset
  return dregs;
}

void THwRpPioPrg::Init(uint8_t adevnum, uint8_t aoffset)
{
  dregs = hwpio_init_and_get_regs(adevnum);
  if (!dregs)
  {
    return;
  }

  offset = aoffset;
  entry = aoffset;
  Clear();
}

void THwRpPioPrg::Add(uint16_t ainstr)
{
  if (offset + length < 32)
  {
    // Add offset to the JMP instruction address
    if ((ainstr & 0xE000) == 0)
    {
      ainstr += offset;
    }

    dregs->instr_mem[offset + length++] = ainstr;
  }
}

void THwRpPioPrg::Clear()
{
  length = 0;
  wrap_start = 0;
}

//---------------------------------------------------------------------------------------

bool THwRpPioSm::Init(uint8_t adevnum, uint8_t asmnum)
{
  initialized = false;
  devnum = adevnum;
  smnum  = asmnum;

  dregs = hwpio_init_and_get_regs(adevnum);
  if (!dregs)
  {
    return false;
  }

  if (smnum > 4)
  {
    return false;
  }

  regs = &dregs->sm[smnum];

  Stop();  // ensure that the state machine is not running

  ClearFifos(); // Clear FIFOs and their debug flags

  tx_lsb   = (uint32_t *)&dregs->txf[smnum];
  tx_msb8 = (uint8_t *)tx_lsb;
  tx_msb8 += 3;
  tx_msb16 = (uint16_t *)tx_lsb;
  tx_msb16 += 1;

  rx_lsb   = (uint32_t *)&dregs->rxf[smnum];
  rx_msb8 = (uint8_t *)rx_lsb;
  rx_msb8 += 3;
  rx_msb16 = (uint16_t *)rx_lsb;
  rx_msb16 += 1;

  tx_fifo_full_bit  = (1 << (16 + smnum));
  rx_fifo_emtpy_bit = (1 << ( 8 + smnum));

  SetClkDiv(clkdiv);

  initialized = true;
  return true;
}

void THwRpPioSm::ClearFifos()
{
  regs->shiftctrl ^= PIO_SM0_SHIFTCTRL_FJOIN_RX_BITS;
  regs->shiftctrl ^= PIO_SM0_SHIFTCTRL_FJOIN_TX_BITS;

  const uint32_t fdebug_sm_mask =
              (1u << PIO_FDEBUG_TXOVER_LSB) |
              (1u << PIO_FDEBUG_RXUNDER_LSB) |
              (1u << PIO_FDEBUG_TXSTALL_LSB) |
              (1u << PIO_FDEBUG_RXSTALL_LSB);
  dregs->fdebug = fdebug_sm_mask << smnum;
}

uint32_t THwRpPioSm::GetDmaRequest(bool istx)
{
  uint32_t result = DREQ_PIO0_TX0 + smnum + (devnum << 3);
  if (!istx)  result += 4;
  return result;
}

void THwRpPioSm::SetPrg(THwRpPioPrg * aprg)
{
  prg = aprg;

  if (prg->wrap_end > prg->length)  prg->wrap_end = prg->length;

  execctrl &= ~(0x3FF << 7); // clear WRAP_TOP, WRAP_BOTTOM
  execctrl |=  (((prg->offset + prg->wrap_start) << 7) | ((prg->offset + prg->wrap_end - 1) << 12));
  regs->execctrl = execctrl;
}

void THwRpPioSm::SetupPinsSideSet(unsigned abase, unsigned acount, bool optional, bool pindir)
{
  sideset_len = (acount & 7);
  pinctrl &= ~((0x1F  << 10) | (0x7         << 29));
  pinctrl |=  ((abase << 10) | (sideset_len << 29));
  regs->pinctrl = pinctrl;

  execctrl &= ~(PIO_SM0_EXECCTRL_SIDE_EN_BITS | PIO_SM0_EXECCTRL_SIDE_PINDIR_BITS);
  execctrl |= (optional << PIO_SM0_EXECCTRL_SIDE_EN_LSB);
  execctrl |= (pindir << PIO_SM0_EXECCTRL_SIDE_PINDIR_LSB);
  regs->execctrl = execctrl;

  SetupPioPins(abase, acount);
}

void THwRpPioSm::SetupPinsSet(unsigned abase, unsigned acount)
{
  pinctrl &= ~((0x1F  << 5) | (0x7    << 26));
  pinctrl |=  ((abase << 5) | (acount << 26));
  regs->pinctrl = pinctrl;
  SetupPioPins(abase, acount);
}

void THwRpPioSm::SetupPinsOut(unsigned abase, unsigned acount, unsigned aextra_flags)
{
  pinctrl &= ~((0x1F  << 0) | (0x3F   << 20));
  pinctrl |=  ((abase << 0) | (acount << 20));
  regs->pinctrl = pinctrl;
  SetupPioPins(abase, acount, aextra_flags);
}

void THwRpPioSm::SetupPinsIn(unsigned abase, unsigned acount, unsigned aextra_flags)
{
  pinctrl &= ~((0x1F  << 15));
  pinctrl |=  ((abase << 15));
  regs->pinctrl = pinctrl;
  SetupPioPins(abase, acount, aextra_flags);
}

void THwRpPioSm::SetupPinsJmp(unsigned abase, unsigned acount)
{
  execctrl &= ~(PIO_SM0_EXECCTRL_JMP_PIN_BITS);
  execctrl |= ((abase & 31) << PIO_SM0_EXECCTRL_JMP_PIN_LSB);
  regs->execctrl = execctrl;
}

void THwRpPioSm::SetClkDiv(uint32_t aclkdiv)
{
  clkdiv = aclkdiv;
  regs->clkdiv = clkdiv;
}

void THwRpPioSm::SetClkDiv(uint32_t abasespeed, uint32_t targetfreq)
{
  unsigned long long divi = abasespeed / targetfreq;
  unsigned long long divf;
  if (divi < 1)
  {
    divi = 1;
    divf = 0;
  }
  else
  {
    divf = ((abasespeed - divi * targetfreq) << 8) / targetfreq;
  }
  SetClkDiv(uint32_t((divi << 16) + (divf << 8)));
}

void THwRpPioSm::SetupPioPins(unsigned abase, unsigned acount, unsigned aextra_flags)
{
  int af;
  switch (devnum)
  {
    case 0: af = PINCFG_AF_6; break;
    case 1: af = PINCFG_AF_7; break;
    case 2: af = PINCFG_AF_8; break;
    default: return; // TODO Not smart
  }

  for (unsigned n = 0; n < acount; ++n)
  {
    hwpinctrl.PinSetup(0, abase + n, af | aextra_flags);
  }
}

void THwRpPioSm::SetPinDir(uint32_t apin, unsigned aoutput)
{
  uint32_t prev_pinctrl = regs->pinctrl;

  regs->pinctrl = (apin << 5) | (1 << 26);   // change the pinctrl for the SET instructions
  regs->instr = pio_encode_set(pio_pindirs, aoutput);
  regs->pinctrl = prev_pinctrl;
}

void THwRpPioSm::Start()
{
/*
  if (!initialized)
  {
    return;
  }
*/

  //regs->shiftctrl = shiftctrl;
  //regs->execctrl  = execctrl;

  regs->instr = pio_encode_jmp(prg->entry);  // force jump to the entry point

  uint32_t tmp = (dregs->ctrl & 0xF);
  tmp |= (1 << smnum); // start the state machine
  dregs->ctrl = tmp;
}

void THwRpPioSm::Stop()
{
  uint32_t tmp = (dregs->ctrl & 0xF);
  tmp &= ~(1 << smnum); // stop the state machine
  dregs->ctrl = tmp;
}

void THwRpPioSm::SetOutShift(bool shift_right, bool autopull, unsigned threshold)
{
  shiftctrl &= ~(PIO_SM0_SHIFTCTRL_OUT_SHIFTDIR_BITS | PIO_SM0_SHIFTCTRL_AUTOPULL_BITS | PIO_SM0_SHIFTCTRL_PULL_THRESH_BITS);
  if (shift_right)  shiftctrl |= PIO_SM0_SHIFTCTRL_OUT_SHIFTDIR_BITS;
  if (autopull)     shiftctrl |= PIO_SM0_SHIFTCTRL_AUTOPULL_BITS;
  shiftctrl |= ((threshold & 0x1F) << PIO_SM0_SHIFTCTRL_PULL_THRESH_LSB);

  regs->shiftctrl = shiftctrl;
}

void THwRpPioSm::SetInShift(bool shift_right, bool autopush, unsigned threshold)
{
  shiftctrl &= ~(PIO_SM0_SHIFTCTRL_IN_SHIFTDIR_BITS | PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS | PIO_SM0_SHIFTCTRL_PUSH_THRESH_BITS);
  if (shift_right)  shiftctrl |= PIO_SM0_SHIFTCTRL_IN_SHIFTDIR_BITS;
  if (autopush)     shiftctrl |= PIO_SM0_SHIFTCTRL_AUTOPUSH_BITS;
  shiftctrl |= ((threshold & 0x1F) << PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB);

  regs->shiftctrl = shiftctrl;
}

bool THwRpPioSm::TrySend32(uint32_t adata)
{
  if (dregs->fstat & tx_fifo_full_bit) // TX FIFO FULL ?
  {
    return false;
  }

  *tx_lsb = adata;
  return true;
}

bool THwRpPioSm::TrySend16(uint16_t adata)
{
  if (dregs->fstat & tx_fifo_full_bit) // TX FIFO FULL ?
  {
    return false;
  }

  *tx_lsb = adata;
  return true;
}

bool THwRpPioSm::TrySend8(uint8_t adata)
{
  if (dregs->fstat & tx_fifo_full_bit) // TX FIFO FULL ?
  {
    return false;
  }

  *tx_lsb = adata;
  return true;
}


bool THwRpPioSm::TryRecv32(uint32_t * adata)
{
  if (dregs->fstat & rx_fifo_emtpy_bit) // RX FIFO EMPTY ?
  {
    return false;
  }

  *adata = *rx_lsb;
  return true;
}

bool THwRpPioSm::TryRecv16(uint16_t * adata)
{
  if (dregs->fstat & rx_fifo_emtpy_bit) // RX FIFO EMPTY ?
  {
    return false;
  }

  *adata = *(uint16_t *)rx_lsb;
  return true;
}

bool THwRpPioSm::TryRecv8(uint8_t * adata)
{
  if (dregs->fstat & rx_fifo_emtpy_bit) // RX FIFO EMPTY ?
  {
    return false;
  }

  *adata = *(uint8_t *)rx_lsb;
  return true;
}


bool THwRpPioSm::TrySendMsb8(uint8_t adata)
{
  if (dregs->fstat & tx_fifo_full_bit) // TX FIFO FULL ?
  {
    return false;
  }

  *tx_msb8 = adata;
  return true;
}

bool THwRpPioSm::TryRecvMsb8(uint8_t * adata)
{
  if (dregs->fstat & rx_fifo_emtpy_bit) // RX FIFO EMPTY ?
  {
    return false;
  }

  *adata = *rx_msb8;
  return true;
}


bool THwRpPioSm::TrySendMsb16(uint16_t adata)
{
  if (dregs->fstat & tx_fifo_full_bit) // TX FIFO FULL ?
  {
    return false;
  }

  *tx_msb16 = adata;
  return true;
}

bool THwRpPioSm::TryRecvMsb16(uint16_t * adata)
{
  if (dregs->fstat & rx_fifo_emtpy_bit) // RX FIFO EMPTY ?
  {
    return false;
  }

  *adata = *rx_msb16;
  return true;
}
